# UWBViewerSystem キャリブレーションガイド

本ドキュメントでは、UWBViewerSystemにおけるアンテナのキャリブレーション（位置合わせ）手順を説明します。

## 目次

1. [キャリブレーションとは](#キャリブレーションとは)
2. [自動アンテナキャリブレーション](#自動アンテナキャリブレーション)
3. [マップベースキャリブレーション（手動配置）](#マップベースキャリブレーション手動配置)
4. [うまくいかないときは](#うまくいかないときは)
5. [ログの見方](#ログの見方)
6. [詳細な技術情報](#詳細な技術情報)

---

## キャリブレーションとは

### なぜキャリブレーションが必要なの？

UWBアンテナは、タグまでの**距離**と**方向**を測定できますが、アンテナ自身が部屋のどこにあるのかは知りません。

例えば、アンテナが「タグは右に3m、前に2mの位置にある」と言っても、アンテナ自身がどこにいるかわからなければ、タグの正確な位置はわかりませんよね。

**キャリブレーション（校正）**とは、このアンテナの位置と向きを正確に測定する作業のことです。

### 例えで理解しよう

学校の教室で考えてみましょう：

```
教室
┌─────────────────────────┐
│                         │
│    [先生の机]           │
│         📍             │
│                         │
│  [生徒A]    [生徒B]    │
│    👤        👤         │
│                         │
└─────────────────────────┘
```

もし先生の机にアンテナがあって、「生徒Aは前に3m、右に2m」と測定できても、**先生の机自体がどこにあるか**がわからないと、生徒Aの教室内での正確な位置はわかりません。

キャリブレーションは、この「先生の机の位置」を測定する作業です！

### 2つのキャリブレーション方法

UWBViewerSystemでは、2種類の方法があります：

| 方法 | 特徴 | 精度 | 時間 | おすすめ度 |
|------|------|------|------|-----------|
| **自動キャリブレーション** | コンピュータが自動計算 | 高精度（誤差10cm以下） | 5〜10分 | ⭐⭐⭐⭐⭐ |
| **手動配置** | マップ上でドラッグ操作 | ユーザー次第 | 1〜2分 | ⭐⭐⭐ |

**初めての人や正確な測定が必要な人は、自動キャリブレーションがおすすめです！**

---

## 自動アンテナキャリブレーション

### 基本的な考え方

自動キャリブレーションの仕組みは、**三角測量**と似ています。

#### ステップ1: 既知の位置にタグを置く

まず、部屋の中の「正確にわかっている位置」にタグを3つ置きます。

```
部屋の見取り図
┌─────────────────────────┐
│                         │
│    Tag2 (3m, 4m)        │
│         ●              │
│                         │
│                         │
│  Tag1       Tag3        │
│  (1m, 1m)   (5m, 1m)    │
│      ●         ●        │
│                         │
│      📡 ← アンテナ      │
│    （位置不明）         │
└─────────────────────────┘
```

#### ステップ2: アンテナで測定

アンテナは各タグまでの距離と方向を測定します：
- Tag1まで: 距離2.5m、方向135度
- Tag2まで: 距離4.2m、方向75度
- Tag3まで: 距離3.8m、方向45度

#### ステップ3: コンピュータが計算

3つのタグの「本当の位置」と「アンテナから見た位置」を比べることで、コンピュータがアンテナの位置と向きを逆算します！

これは算数の連立方程式を解くのと同じ原理です。

### 準備するもの

- **UWBタグ**: 最低3個（できれば3〜5個）
- **メジャー（巻き尺）**: タグの位置を正確に測るため
- **部屋の図面**: フロアマップとして登録
- **時間**: 約10分

### 手順

#### 手順1: フロアマップを登録

1. 部屋の図面（画像）を用意します
2. 「Floor Map」タブで図面を登録します
3. スケール（縮尺）を設定します
   - 例: 図面上の1cmが実際の50cmなど

#### 手順2: タグを配置

**重要なポイント**:
- タグは**三角形になるように**置いてください
- タグを一直線に並べると、計算ができません！

```
❌ 悪い例（一直線）:
  ●────●────●
 Tag1  Tag2  Tag3

理由: 3点が一直線だと、アンテナの向きが特定できません
     （どの向きでも同じ測定結果になってしまう）

✅ 良い例（三角形）:
      ●
     Tag2
    /   \
   ●─────●
  Tag1   Tag3

理由: 三角形なら、アンテナの位置も向きも一意に決まります
```

**配置のコツ**:

1. **広く散らばせる**: タグ同士は2m以上離す
2. **同じ高さにする**: 全部床から1m〜1.5mくらい
3. **障害物を避ける**: タグとアンテナの間に壁や家具がないように

#### 手順3: タグの正確な位置を測定

メジャーを使って、各タグの位置を測ります：

```
例:
Tag1: X座標 = 1.0m, Y座標 = 1.0m, 高さ = 1.2m
Tag2: X座標 = 3.0m, Y座標 = 4.0m, 高さ = 1.2m
Tag3: X座標 = 5.0m, Y座標 = 1.0m, 高さ = 1.2m
```

**測定のコツ**:
- 部屋の角を原点（0, 0）とすると測りやすい
- X座標: 横方向の距離
- Y座標: 縦方向の距離
- 高さ: 床からの高さ

#### 手順4: アプリでキャリブレーション開始

1. 「Floor Map」タブを開く
2. 「自動アンテナキャリブレーション」ボタンをタップ
3. 「タグ位置を追加」で、測定した位置を入力
   - Tag1: (1.0, 1.0, 1.2)
   - Tag2: (3.0, 4.0, 1.2)
   - Tag3: (5.0, 1.0, 1.2)
4. 「キャリブレーション開始」をタップ

#### 手順5: 測定を待つ

アプリが自動的に以下を行います：

1. **Tag1での測定**（約30秒）
   - アンテナがTag1を何度も測定
   - 測定データを集める

2. **Tag2での測定**（約30秒）
   - 同じように測定

3. **Tag3での測定**（約30秒）
   - 同じように測定

4. **計算**（数秒）
   - 集めたデータからアンテナの位置を計算
   - 計算結果を表示

#### 手順6: 結果を確認

計算が終わると、以下の情報が表示されます：

```
✅ キャリブレーション成功！

アンテナ位置: (2.5m, 3.2m)
アンテナの向き: 45.3°
精度（RMSE）: 0.12m
```

**見方**:
- **アンテナ位置**: 部屋の中でアンテナがある場所
- **アンテナの向き**: アンテナの正面の方向（0°=右、90°=上）
- **精度（RMSE）**: 測定の誤差（小さいほど良い）
  - 0.5m以下なら合格！
  - 0.1m以下なら素晴らしい！

#### 手順7: 保存

結果に問題がなければ、「保存」ボタンをタップして完了です！

### キャリブレーションがうまくいくコツ

#### 1. タグの配置が最重要

```
◎ 最高の配置:
- 三角形または四角形
- タグ間の距離が均等
- 部屋の端の方に配置

例:
┌─────────────────────┐
│●                  ●│ ← 部屋の隅に配置
│                    │
│                    │
│         ●          │ ← 真ん中にも1つ
│                    │
│                    │
│●                  ●│
└─────────────────────┘
```

#### 2. 測定環境を整える

- **障害物なし**: タグとアンテナの間に壁や大きな家具がない
- **静かな環境**: 測定中は人が動き回らない
- **電波干渉なし**: Wi-Fiルーターなどから離す

#### 3. 測定時間は十分に

各タグで30秒測定すれば、だいたい15〜20回のデータが集まります。これくらいあれば、平均をとることで誤差を減らせます。

---

## マップベースキャリブレーション（手動配置）

### こんな人におすすめ

- とりあえず試してみたい人
- 大まかな位置がわかればいい人
- 時間がない人

### 手順

1. 「Floor Map」タブを開く
2. 「アンテナ配置」モードに切り替え
3. アンテナアイコンを見取り図上でドラッグ
4. 回転ハンドルでアンテナの向きを調整
5. 「保存」をタップ

### 注意点

手動配置の精度は、あなたの配置の正確さ次第です。より正確な測定が必要な場合は、自動キャリブレーションを使いましょう。

---

## うまくいかないときは

### エラー1: 「測定データがありません」

**何が起きた？**: アンテナから測定データが届いていません

**原因**:
- ネットワークが切れた
- データ送信に時間がかかっている

**解決方法**:
1. アンテナとの接続を確認
2. もう一度キャリブレーションをやり直す
3. 測定時間を60秒に伸ばしてみる

### エラー2: 「測定点が一直線上に並んでいます」

**何が起きた？**: タグが一直線に並んでいるため、計算ができません

```
あなたの配置:
  ●────●────●  ← 一直線！
 Tag1  Tag2  Tag3
```

**なぜダメ？**: 一直線だと、アンテナの向きが特定できないからです

例えばこの図を見てください：

```
場合1: アンテナが下向き
      ●────●────●
      ↓
     📡

場合2: アンテナが右向き
      ●────●────●
             ↘
               📡
```

どちらの場合も、タグまでの距離はほぼ同じになってしまい、区別できません！

**解決方法**: タグを三角形に配置し直してください

```
正しい配置:
      ●
     Tag2
    /   \
   ●─────●
  Tag1   Tag3
```

### エラー3: 「精度が悪い（RMSE > 1.0m）」

**何が起きた？**: 計算はできたけど、誤差が大きい

**原因**:
- タグとアンテナの間に障害物がある
- タグの位置測定が間違っている
- 電波干渉がある

**解決方法**:
1. 障害物を取り除く
2. タグの位置をメジャーで測り直す
3. タグの数を増やす（3個→5個）
4. 測定時間を長くする

### エラー4: 「特異行列エラー」

**何が起きた？**: タグの配置が悪くて、計算が不安定

**原因**:
- タグ同士が近すぎる
- タグの配置がほぼ一直線に近い

**解決方法**:
1. タグ間の距離を2m以上に広げる
2. タグを部屋の隅の方に配置
3. タグの高さを揃える

---

## ログの見方

キャリブレーション中、アプリは詳しいログを表示します。

### 成功した場合のログ

```
🚀 自動キャリブレーション開始
   対象アンテナ: 1個
   真のタグ位置: 3個

📡 C032DB36... のキャリブレーション
   使用可能なタグ: 3個
   各タグの観測数: ["Tag1": 18, "Tag2": 20, "Tag3": 19]

📊 平均化された測定点（アンテナから見た位置）:
   Point1: (1.023, 0.987)
   Point2: (2.976, 3.912)
   Point3: (4.889, 1.034)

📍 真の位置（メジャーで測った位置）:
   Point1: (1.000, 1.000)
   Point2: (3.000, 4.000)
   Point3: (5.000, 1.000)

🔍 共線性チェック: 外積の絶対値 = 8.923456
   → OK! タグは三角形に配置されています

✅ キャリブレーション成功

推定アンテナ位置: (2.531, 3.187)
角度: 45.3°
RMSE: 0.123m

🎉 完了！
💾 データを保存しました
```

### チェックポイント

| 項目 | 良い値 | 説明 |
|------|--------|------|
| **観測数** | 各タグ5回以上 | 測定データの数 |
| **外積の値** | 0.01以上 | 大きいほどタグの配置が良い |
| **RMSE** | 0.5m以下 | 測定の誤差（小さいほど良い） |

---

## 詳細な技術情報

このセクションは、線形代数の基礎知識（行列、ベクトル、固有値・固有ベクトル）がある人向けの詳細な説明です。

### キャリブレーションの数学的定式化

#### 1. 問題設定

**目的**: ローカル座標系（アンテナ座標系）からグローバル座標系（部屋座標系）への2Dアフィン変換を推定し、アンテナの位置と向きを求める。

**座標系の定義**:
- **グローバル座標系** (ワールド座標): フロアマップ上の絶対座標
  - 原点: フロアマップの左上
  - 軸: X軸=右方向、Y軸=下方向
- **ローカル座標系** (アンテナ座標): アンテナから見た相対座標
  - 原点: アンテナの位置
  - 軸: アンテナの向きに依存（回転）

**入力データ**:
- **真のタグ位置** (既知): `T = {t₁, t₂, ..., tₙ}` where `tᵢ ∈ ℝ²`
- **観測されたタグ位置** (測定値): `S = {s₁, s₂, ..., sₙ}` where `sᵢ ∈ ℝ²`
  - 各タグで複数回測定: `Sᵢ = {sᵢ₁, sᵢ₂, ..., sᵢₘ}`

**出力**:
- アンテナ位置: `(tx, ty) ∈ ℝ²`
- アンテナ向き: `θ ∈ [0, 2π)`
- 推定精度: RMSE

#### 2. 2Dアフィン変換

**アフィン変換の一般形**:

```
p' = Ap + t
```

行列表現:
```
[x']   [a₁₁  a₁₂] [x]   [tx]
[y'] = [a₂₁  a₂₂] [y] + [ty]
```

ここで：
- `A ∈ ℝ²ˣ²`: 線形変換行列（回転・スケール・せん断）
- `t ∈ ℝ²`: 平行移動ベクトル
- パラメータ数: 6 (a₁₁, a₁₂, a₂₁, a₂₂, tx, ty)

**同次座標表現** (計算上便利):

```
[x']   [a₁₁  a₁₂  tx] [x]
[y'] = [a₂₁  a₂₂  ty] [y]
[1 ]   [0    0    1 ] [1]
```

#### 3. 詳細な計算の流れ

##### ステップ1: データ前処理

**測定値の平均化** (ノイズ低減):

各タグiについて、m回の測定値 `{sᵢ₁, sᵢ₂, ..., sᵢₘ}` の平均を計算：

```
s̄ᵢ = (1/m) Σⱼ₌₁ᵐ sᵢⱼ
```

実装: `AntennaAffineCalibration.swift` の `estimateAntennaConfig()`

```swift
let averagedPoint = Point3D(
    x: measurements.map(\.x).reduce(0, +) / Double(measurements.count),
    y: measurements.map(\.y).reduce(0, +) / Double(measurements.count),
    z: measurements.map(\.z).reduce(0, +) / Double(measurements.count)
)
```

**共線性チェック** (退化ケースの検出):

3点 P₁, P₂, P₃ の外積で判定：

```
v₁ = P₂ - P₁
v₂ = P₃ - P₁
外積 = v₁ₓ · v₂ᵧ - v₁ᵧ · v₂ₓ
```

- `|外積| < ε (= 0.01)` ならば共線 → エラー
- 外積は平行四辺形の面積に等しい

##### ステップ2: 最小二乗法によるアフィン変換の推定

**問題の定式化**:

n個の対応点 `(sᵢ, tᵢ)` が与えられたとき、以下を最小化：

```
E = Σᵢ₌₁ⁿ ||tᵢ - (Asᵢ + t)||²
```

**正規方程式の構築**:

各点について、以下の2つの方程式が得られる：

```
x'ᵢ = a₁₁xᵢ + a₁₂yᵢ + tx
y'ᵢ = a₂₁xᵢ + a₂₂yᵢ + ty
```

これを行列形式で表す：

```
[x₁  y₁  1   0   0  0] [a₁₁]   [x'₁]
[0   0   0  x₁  y₁  1] [a₁₂]   [y'₁]
[x₂  y₂  1   0   0  0] [a₂₁]   [x'₂]
[0   0   0  x₂  y₂  1] [a₂₂] = [y'₂]
[...                 ] [tx ]   [...]
[xₙ  yₙ  1   0   0  0] [ty ]   [x'ₙ]
[0   0   0  xₙ  yₙ  1]         [y'ₙ]
```

つまり：
```
Mθ = b
```

ここで：
- `M ∈ ℝ²ⁿˣ⁶`: 係数行列
- `θ ∈ ℝ⁶`: パラメータベクトル `[a₁₁, a₁₂, a₂₁, a₂₂, tx, ty]ᵀ`
- `b ∈ ℝ²ⁿ`: ターゲットベクトル `[x'₁, y'₁, x'₂, y'₂, ..., x'ₙ, y'ₙ]ᵀ`

**最小二乗解**:

正規方程式 `MᵀMθ = Mᵀb` を解く：

```
θ = (MᵀM)⁻¹Mᵀb
```

実装では、LAPACKの `dgels_` を使用して直接解く（数値的に安定）。

**LAPACK dgels_ の使用**:

```swift
var transN: Int8 = 78  // 'N' = No transpose
var m: __CLPK_integer = __CLPK_integer(2 * n)  // 行数 = 2n
var n: __CLPK_integer = 6  // 列数 = 6 (パラメータ数)
var nrhs: __CLPK_integer = 1  // 右辺の列数

dgels_(
    &transN,     // 転置フラグ
    &m,          // 行数
    &n,          // 列数
    &nrhs,       // 右辺の列数
    &matrixA,    // 係数行列 (列優先)
    &lda,        // leading dimension
    &vectorB,    // 右辺ベクトル (解が上書きされる)
    &ldb,        // leading dimension
    &work,       // ワークスペース
    &lwork,      // ワークスペースサイズ
    &info        // エラーコード
)
```

**重要**: LAPACKは列優先（column-major）形式なので、行列を転置して渡す必要がある。

##### ステップ3: SVDによる回転角度とスケールの抽出

推定された線形変換行列 `A` を、回転成分とスケール成分に分解する。

**特異値分解 (SVD)**:

```
A = UΣVᵀ
```

ここで：
- `U, V ∈ ℝ²ˣ²`: 直交行列 (`UᵀU = VᵀV = I`)
- `Σ = diag(σ₁, σ₂)`: 対角行列（特異値、σ₁ ≥ σ₂ > 0）

**回転行列の抽出**:

```
R = UVᵀ
```

`R` は回転行列（det(R) = ±1）。もし det(R) = -1 なら、鏡像変換を含むので補正が必要。

**回転角度の計算**:

回転行列の形：
```
R = [cos(θ)  -sin(θ)]
    [sin(θ)   cos(θ)]
```

回転角度は：
```
θ = atan2(R₂₁, R₁₁)  (ラジアン)
```

`atan2` を使うことで、全ての象限で正しい角度が得られる。

**スケール係数**:

```
sx = σ₁  (X方向のスケール)
sy = σ₂  (Y方向のスケール)
```

理想的には `sx ≈ sy ≈ 1` (スケール変化なし)。

**LAPACK dgesvd_ の使用**:

```swift
var jobU: Int8 = 65    // 'A' = All U
var jobVT: Int8 = 65   // 'A' = All VT
var m: __CLPK_integer = 2
var n: __CLPK_integer = 2

dgesvd_(
    &jobU,           // U の計算方法
    &jobVT,          // Vᵀ の計算方法
    &m, &n,          // 行列のサイズ
    &A_copy,         // 入力行列 (破壊される)
    &lda,            // leading dimension
    &singularValues, // 特異値 (出力)
    &U,              // U行列 (出力)
    &ldu,            // leading dimension
    &VT,             // Vᵀ行列 (出力)
    &ldvt,           // leading dimension
    &work,           // ワークスペース
    &lwork,          // ワークスペースサイズ
    &info            // エラーコード
)
```

##### ステップ4: アンテナ位置の決定

推定されたアフィン変換 `p' = Ap + t` は：
- ローカル座標系の点 `p` をグローバル座標系の点 `p'` に変換

したがって：
- `t = (tx, ty)` がローカル座標系の原点（= アンテナ位置）のグローバル座標

**結果**:
```
アンテナ位置 = t = (tx, ty)
アンテナ向き = θ (度数法に変換: θ_deg = θ × 180/π)
```

##### ステップ5: 精度評価 (RMSE)

**変換後の残差計算**:

各ソース点 `sᵢ` を変換：
```
p'ᵢ = Asᵢ + t
```

ターゲット点 `tᵢ` との誤差：
```
eᵢ = ||tᵢ - p'ᵢ||₂ = √((tᵢₓ - p'ᵢₓ)² + (tᵢᵧ - p'ᵢᵧ)²)
```

**RMSE (Root Mean Square Error)**:

```
RMSE = √((1/n) Σᵢ₌₁ⁿ eᵢ²)
```

実装:
```swift
let transformed = self.applyTransform(transform: transform, point: source)
let error = sqrt(
    pow(target.x - transformed.x, 2) +
    pow(target.y - transformed.y, 2)
)
totalSquaredError += error * error
```

```swift
let rmse = sqrt(totalSquaredError / Double(sourcePoints.count))
```

**RMSEの解釈**:
- < 0.1m: 非常に良好
- < 0.5m: 良好（目標値）
- < 1.0m: 許容範囲
- ≥ 1.0m: 改善が必要

#### 4. 数値計算上の注意点

##### 列優先形式 (Column-Major Order)

LAPACKはFortran由来のため、行列を列優先で格納：

```
A = [a₁₁  a₁₂]  →  [a₁₁, a₂₁, a₁₂, a₂₂]  (メモリ上)
    [a₂₁  a₂₂]
```

C/Swiftは行優先なので、転置して渡す必要がある：

```swift
// 行優先 → 列優先への変換
var matrixA: [Double] = []
for col in 0..<n {
    for row in 0..<m {
        matrixA.append(matrix[row][col])
    }
}
```

##### 数値的安定性

**条件数** (Condition Number):

行列 `M` の条件数 `κ(M) = ||M|| · ||M⁻¹||` が大きいと、解が不安定になる。

対策:
- タグを広く分散配置（条件数を小さくする）
- 正則化項の追加（必要に応じて）
- データの正規化

**特異行列の検出**:

SVDの特異値 `σ₂` が非常に小さい（≈ 0）場合、行列がほぼ特異。
- タグが一直線上 → `σ₂ ≈ 0`
- 共線性チェックで事前に検出

##### 共線性の判定閾値

外積の閾値 `ε = 0.01` は経験的に決定。

幾何学的意味:
- 外積 = 2つのベクトルが張る平行四辺形の面積
- `ε = 0.01` → 約 10cm × 10cm の面積

#### 5. 具体的な計算例

**設定**:
- Tag1: (1.0, 1.0)
- Tag2: (3.0, 4.0)
- Tag3: (5.0, 1.0)

アンテナから見た測定値（平均化後）:
- s₁ = (1.023, 0.987)
- s₂ = (2.976, 3.912)
- s₃ = (4.889, 1.034)

**係数行列 M** (6×6, n=3の場合):

```
M = [1.023  0.987  1   0      0      0  ]
    [0      0      0   1.023  0.987  1  ]
    [2.976  3.912  1   0      0      0  ]
    [0      0      0   2.976  3.912  1  ]
    [4.889  1.034  1   0      0      0  ]
    [0      0      0   4.889  1.034  1  ]
```

**ターゲットベクトル b**:

```
b = [1.0, 1.0, 3.0, 4.0, 5.0, 1.0]ᵀ
```

**最小二乗解 θ**:

dgels_ を用いて求めると（仮の結果）:
```
θ = [0.998, -0.052, 0.052, 0.998, 0.531, 1.187]ᵀ
```

したがって：
```
A = [0.998  -0.052]   ≈ [cos(3°)  -sin(3°)]
    [0.052   0.998]     [sin(3°)   cos(3°)]

t = [0.531, 1.187]ᵀ
```

**SVDで分解**:

```
σ₁ ≈ 1.001, σ₂ ≈ 0.999  (ほぼ1 → スケール変化なし)
θ ≈ atan2(0.052, 0.998) ≈ 3.0°
```

**結果**:
```
アンテナ位置: (0.531, 1.187)
アンテナ向き: 3.0°
```

#### 6. アルゴリズムの疑似コード

```python
def calibrate_antenna(measured_points, true_positions):
    # ステップ1: 平均化
    averaged_measured = {tag: mean(points) for tag, points in measured_points.items()}

    # ステップ2: 共線性チェック
    if is_collinear(averaged_measured.values()):
        raise Error("Points are collinear")

    # ステップ3: 正規方程式の構築
    M, b = build_normal_equations(averaged_measured, true_positions)

    # ステップ4: 最小二乗解
    theta = solve_least_squares(M, b)  # LAPACK dgels_
    A = [[theta[0], theta[1]],
         [theta[2], theta[3]]]
    t = [theta[4], theta[5]]

    # ステップ5: SVD分解
    U, Sigma, Vt = svd(A)  # LAPACK dgesvd_
    R = U @ Vt
    scale_x, scale_y = Sigma[0], Sigma[1]

    # ステップ6: 回転角度
    theta_rad = atan2(R[1][0], R[0][0])
    theta_deg = theta_rad * 180 / pi

    # ステップ7: RMSE計算
    rmse = compute_rmse(A, t, averaged_measured, true_positions)

    return {
        'position': t,
        'angle': theta_deg,
        'scale': (scale_x, scale_y),
        'rmse': rmse
    }
```

### 理論的背景

#### アフィン変換の性質

1. **線形性**: 直線は直線に、平行線は平行線に写る
2. **比の保存**: 線分の長さの比は保たれる
3. **重心の保存**: 図形の重心は重心に写る

#### 最小二乗法の最適性

- **ガウス・マルコフの定理**: 誤差が独立同分布なら、最小二乗推定量は不偏で最小分散
- **幾何学的解釈**: 残差ベクトルが係数行列の列空間に直交

#### SVDの優位性

- **数値的安定性**: 行列が悪条件でも安定に計算可能
- **一意性**: 特異値は一意に決まる（符号の不定性を除く）
- **低ランク近似**: 最良のランクk近似を与える

### 参考文献

**基礎理論**:
- Gilbert Strang, "Linear Algebra and Its Applications" (線形代数の基礎)
- Horn, B. K. P. (1987), "Closed-form solution of absolute orientation using unit quaternions", *J. Optical Society of America A*, 4(4), 629-642

**実装**:
- Anderson, E., et al. (1999), *LAPACK Users' Guide*, Third Edition, SIAM
- Umeyama, S. (1991), "Least-squares estimation of transformation parameters between two point patterns", *IEEE Trans. PAMI*, 13(4), 376-380

**実装詳細**: `AntennaAffineCalibration.swift` のソースコード

---

## 関連ファイル

プログラムのどこを見ればいいか：

- **自動キャリブレーションの画面**: `UWBViewerSystem/Presentation/Scenes/FloorMapTab/AutoAntennaCalibrationPage/AutoAntennaCalibrationViewModel.swift`
- **計算のロジック**: `UWBViewerSystem/Domain/Utils/AntennaAffineCalibration.swift`
- **データ管理**: `UWBViewerSystem/Domain/Usecase/AutoAntennaCalibrationUsecase.swift`

---

## バージョン履歴

- **v2.1** (2025-10-14): 線形代数の知識がある人向けに数学的詳細を拡充
  - 問題の数学的定式化を追加（座標系、入力/出力の定義）
  - 計算の流れを5ステップで詳細に説明
  - 正規方程式の構築と最小二乗解の導出を追加
  - SVDによる回転・スケール分解の詳細を追加
  - LAPACKの使用方法と列優先形式の説明を追加
  - 数値計算上の注意点（条件数、特異行列、共線性閾値）を追加
  - 具体的な計算例（係数行列、解の計算）を追加
  - 疑似コードとアルゴリズムの全体像を追加
  - 理論的背景（最小二乗法の最適性、SVDの優位性）を追加

- **v2.0** (2025-10-14): 高校生向けに全面書き直し
  - 専門用語をやさしい言葉に置き換え
  - 図や例を大幅に追加
  - 「なぜそうするのか」を丁寧に説明
  - 数学的背景を直感的に説明

- **v1.1** (2025-10-14): 数学的手順の詳細を追加
  - 問題設定と座標系の定義を追加
  - アフィン変換の数学的推定方法を詳述
  - SVDによる回転角度・スケール抽出の説明を追加
  - アルゴリズムのフローチャートを追加
  - LAPACK実装の注意点を追加
  - 参考文献を追加

- **v1.0** (2025-10-14): 初版作成
  - 自動アンテナキャリブレーションの手順を追加
  - トラブルシューティングセクションを追加
  - 共線性チェック機能の説明を追加
