import Foundation
import SwiftData
import SwiftUI

#if os(macOS)
    import AppKit
#elseif os(iOS)
    import UIKit
#endif

@MainActor
class AntennaPositioningViewModel: ObservableObject {
    @Published var selectedDevices: [AndroidDevice] = []
    @Published var antennaPositions: [AntennaPosition] = []
    @Published var canProceedValue: Bool = false

    #if os(macOS)
        var mapImage: NSImage?
    #elseif os(iOS)
        var mapImage: UIImage?
    #endif
    // mapData: IndoorMapData„ÅØÁèæÂú®Âà©Áî®„Åß„Åç„Å™„ÅÑ„Åü„ÇÅ„ÄÅ‰∏ÄÊôÇÁöÑ„Å´„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„Éà
    // var mapData: IndoorMapData?

    // SwiftDataÈñ¢ÈÄ£
    private var modelContext: ModelContext?
    private var swiftDataRepository: SwiftDataRepository?

    // „Éï„É≠„Ç¢„Éû„ÉÉ„Éó„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
    var floorMapInfo: FloorMapInfo? {
        guard let data = UserDefaults.standard.data(forKey: "currentFloorMapInfo"),
              let info = try? JSONDecoder().decode(FloorMapInfo.self, from: data) else {
            return nil
        }
        return info
    }

    // „Éï„É≠„Ç¢„Éû„ÉÉ„Éó„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØîÔºàwidth/depthÔºâ
    var floorMapAspectRatio: Double {
        guard let info = floorMapInfo else { return 1.0 }
        return info.width / info.depth
    }

    // „Éï„É≠„Ç¢„Éû„ÉÉ„Éó„ÅÆ„Çπ„Ç±„Éº„É´Ôºà„É°„Éº„Éà„É´/„Éî„ÇØ„Çª„É´Ôºâ
    var mapScale: Double {
        // UserDefaults„Åã„Çâ„Éï„É≠„Ç¢„Éû„ÉÉ„ÉóÊÉÖÂ†±„ÇíÂèñÂæó
        guard let info = floorMapInfo else {
            return 0.01 // „Éá„Éï„Ç©„É´„ÉàÂÄ§: 1„Éî„ÇØ„Çª„É´ = 1cm
        }

        // „Éû„ÉÉ„Éó„Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çµ„Ç§„Ç∫„ÅØ400x400„Éî„ÇØ„Çª„É´
        let canvasSize: Double = 400.0

        // „Çà„ÇäÂ§ß„Åç„ÅÑËæ∫„ÇíÂü∫Ê∫ñ„Å´„Çπ„Ç±„Éº„É´„ÇíË®àÁÆóÔºà„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíËÄÉÊÖÆÔºâ
        let maxRealSize = max(info.width, info.depth)
        let scale = maxRealSize / canvasSize

        print("üó∫Ô∏è MapScale calculation: width=\(info.width)m, depth=\(info.depth)m, maxSize=\(maxRealSize)m, canvasSize=\(canvasSize)px, scale=\(scale)m/px")

        return scale
    }

    private let colors: [Color] = [.red, .blue, .green, .orange, .purple, .pink, .cyan, .yellow]

    // ÂàùÊúüÂåñ
    func setModelContext(_ context: ModelContext) {
        modelContext = context
        if #available(macOS 14, iOS 17, *) {
            swiftDataRepository = SwiftDataRepository(modelContext: context)
        }
        loadAntennaPositionsFromSwiftData()
    }

    private func updateCanProceed() {
        // ÂàùÊúü‰ΩçÁΩÆÔºàÊ≠£Ë¶èÂåñÂ∫ßÊ®ô„Åß0.125, 0.125Ôºâ„Åã„ÇâÁßªÂãï„Åï„Çå„Åü„Ç¢„É≥„ÉÜ„Éä„Çí„Ç´„Ç¶„É≥„Éà
        let positionedAntennas = antennaPositions.filter {
            $0.normalizedPosition != CGPoint(x: 0.125, y: 0.125)
        }
        canProceedValue = positionedAntennas.count >= 3
    }

    func getDevicePosition(_ deviceId: String) -> CGPoint {
        antennaPositions.first { $0.id == deviceId }?.position ?? CGPoint(x: 50, y: 50)
    }

    func getDeviceRotation(_ deviceId: String) -> Double {
        antennaPositions.first { $0.id == deviceId }?.rotation ?? 0.0
    }

    func loadMapAndDevices() {
        loadSelectedDevices()
        loadMapData()
        createAntennaPositions()
    }

    private func loadSelectedDevices() {
        if let data = UserDefaults.standard.data(forKey: "SelectedUWBDevices"),
           let decoded = try? JSONDecoder().decode([AndroidDevice].self, from: data)
        {
            selectedDevices = decoded
        }
    }

    private func loadMapData() {
        print("üìç AntennaPositioningViewModel: loadMapData called")

        // currentFloorMapInfo„Åã„ÇâË™≠„ÅøËæº„ÇÄ
        if let data = UserDefaults.standard.data(forKey: "currentFloorMapInfo"),
           let floorMapInfo = try? JSONDecoder().decode(FloorMapInfo.self, from: data) {
            print("üìç AntennaPositioningViewModel: FloorMapInfo loaded - \(floorMapInfo.name)")

            // ‰øùÂ≠ò„Åï„Çå„ÅüÁîªÂÉè„ÇíË™≠„ÅøËæº„ÇÄ
            let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
            let imageURL = documentsDirectory.appendingPathComponent("\(floorMapInfo.id).jpg")

            print("üìç AntennaPositioningViewModel: Looking for image at: \(imageURL.path)")

            // Êñ∞„Åó„ÅÑFloorMapInfoÊßãÈÄ†„Çí‰ΩøÁî®„Åó„Å¶ÁîªÂÉè„ÇíË™≠„ÅøËæº„ÇÄ
            mapImage = floorMapInfo.image
            if mapImage != nil {
                print("‚úÖ AntennaPositioningViewModel: Map image loaded successfully")
            } else {
                print("‚ùå AntennaPositioningViewModel: Failed to load map image")
            }
        } else {
            print("‚ùå AntennaPositioningViewModel: No FloorMapInfo found in UserDefaults")
        }
    }

    private func createAntennaPositions() {
        antennaPositions = selectedDevices.enumerated().map { index, device in
            AntennaPosition(
                id: device.id,
                deviceName: device.name,
                position: CGPoint(x: 50, y: 50),  // „Éá„Éï„Ç©„É´„Éà‰ΩçÁΩÆ
                rotation: 0.0,
                color: colors[index % colors.count],
                baseCanvasSize: CGSize(width: 400, height: 400) // Âü∫Ê∫ñ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫
            )
        }
        updateCanProceed()
    }

    func updateAntennaPosition(_ antennaId: String, position: CGPoint) {
        if let index = antennaPositions.firstIndex(where: { $0.id == antennaId }) {
            antennaPositions[index].position = position
            updateCanProceed()

            // UserDefaults„Å´‰øùÂ≠ò
            saveAntennaPositions()

            // SwiftData„Å´Ëá™Âãï‰øùÂ≠ò
            saveAntennaPositionToSwiftData(antennaPositions[index])

            print("üéØ „Ç¢„É≥„ÉÜ„Éä[\(antennaId)]„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞: (\(position.x), \(position.y))")
        }
    }

    // Ê≠£Ë¶èÂåñÂ∫ßÊ®ô„Çí‰ΩøÁî®„Åó„Åü‰ΩçÁΩÆÊõ¥Êñ∞„É°„ÇΩ„ÉÉ„Éâ
    func updateAntennaPosition(_ antennaId: String, normalizedPosition: CGPoint) {
        if let index = antennaPositions.firstIndex(where: { $0.id == antennaId }) {
            antennaPositions[index].normalizedPosition = normalizedPosition
            // Âü∫Ê∫ñ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫(400x400)„Åß„ÅÆ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
            antennaPositions[index].position = CGPoint(
                x: normalizedPosition.x * 400,
                y: normalizedPosition.y * 400
            )
            updateCanProceed()

            // UserDefaults„Å´‰øùÂ≠ò
            saveAntennaPositions()

            // SwiftData„Å´Ëá™Âãï‰øùÂ≠ò
            saveAntennaPositionToSwiftData(antennaPositions[index])

            print("üéØ „Ç¢„É≥„ÉÜ„Éä[\(antennaId)]„ÅÆÊ≠£Ë¶èÂåñ‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞: (\(normalizedPosition.x), \(normalizedPosition.y))")
        }
    }

    func updateAntennaRotation(_ antennaId: String, rotation: Double) {
        if let index = antennaPositions.firstIndex(where: { $0.id == antennaId }) {
            antennaPositions[index].rotation = rotation

            // UserDefaults„Å´‰øùÂ≠ò
            saveAntennaPositions()

            // SwiftData„Å´Ëá™Âãï‰øùÂ≠ò
            saveAntennaPositionToSwiftData(antennaPositions[index])

            print("üéØ „Ç¢„É≥„ÉÜ„Éä[\(antennaId)]„ÅÆÂêë„Åç„ÇíÊõ¥Êñ∞: \(rotation)¬∞")
        }
    }

    func getAntennaPosition(for deviceId: String) -> CGPoint? {
        antennaPositions.first(where: { $0.id == deviceId })?.position
    }

    func isDevicePositioned(_ deviceId: String) -> Bool {
        if let position = getAntennaPosition(for: deviceId) {
            return position != CGPoint(x: 50, y: 50)  // „Éá„Éï„Ç©„É´„Éà‰ΩçÁΩÆ‰ª•Â§ñ„Å´ÈÖçÁΩÆ„Åï„Çå„Å¶„ÅÑ„Çã„Åã
        }
        return false
    }

    func autoArrangeAntennas() {
        // „Éï„É≠„Ç¢„Éû„ÉÉ„Éó„ÅÆ„Ç¢„Çπ„Éö„ÇØ„ÉàÊØî„ÇíËÄÉÊÖÆ„Åó„ÅüÂü∫Ê∫ñ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
        let baseSize: CGFloat = 400
        let aspectRatio = floorMapAspectRatio

        let canvasSize: CGSize
        if aspectRatio > 1.0 {
            // Ê®™Èï∑
            canvasSize = CGSize(width: baseSize, height: baseSize / aspectRatio)
        } else {
            // Á∏¶Èï∑„Åæ„Åü„ÅØÊ≠£ÊñπÂΩ¢
            canvasSize = CGSize(width: baseSize * aspectRatio, height: baseSize)
        }

        let margin: CGFloat = 60
        let availableWidth = canvasSize.width - (margin * 2)
        let availableHeight = canvasSize.height - (margin * 2)

        let deviceCount = antennaPositions.count

        if deviceCount <= 0 { return }

        // ‰∏âËßíÂΩ¢„ÄÅÂõõËßíÂΩ¢„ÄÅ„Åù„ÅÆ‰ªñ„ÅÆÂΩ¢Áä∂„ÅßËá™ÂãïÈÖçÁΩÆ
        if deviceCount == 3 {
            // ‰∏âËßíÂΩ¢ÈÖçÁΩÆ
            let positions = [
                CGPoint(x: canvasSize.width / 2, y: margin),
                CGPoint(x: margin, y: availableHeight + margin),
                CGPoint(x: availableWidth + margin, y: availableHeight + margin),
            ]
            for (index, position) in positions.enumerated() {
                if index < antennaPositions.count {
                    antennaPositions[index].position = position
                    antennaPositions[index].normalizedPosition = CGPoint(
                        x: position.x / canvasSize.width,
                        y: position.y / canvasSize.height
                    )
                }
            }
        } else if deviceCount == 4 {
            // ÂõõËßíÂΩ¢ÈÖçÁΩÆ
            let positions = [
                CGPoint(x: margin, y: margin),
                CGPoint(x: availableWidth + margin, y: margin),
                CGPoint(x: margin, y: availableHeight + margin),
                CGPoint(x: availableWidth + margin, y: availableHeight + margin),
            ]
            for (index, position) in positions.enumerated() {
                if index < antennaPositions.count {
                    antennaPositions[index].position = position
                    antennaPositions[index].normalizedPosition = CGPoint(
                        x: position.x / canvasSize.width,
                        y: position.y / canvasSize.height
                    )
                }
            }
        } else {
            // ÂÜÜÂΩ¢ÈÖçÁΩÆ
            let center = CGPoint(x: canvasSize.width / 2, y: canvasSize.height / 2)
            let radius = min(availableWidth, availableHeight) / 2

            for (index, _) in antennaPositions.enumerated() {
                let angle = (2 * Double.pi * Double(index)) / Double(deviceCount)
                let x = center.x + CGFloat(cos(angle)) * radius
                let y = center.y + CGFloat(sin(angle)) * radius
                let position = CGPoint(x: x, y: y)
                antennaPositions[index].position = position
                antennaPositions[index].normalizedPosition = CGPoint(
                    x: position.x / canvasSize.width,
                    y: position.y / canvasSize.height
                )
            }
        }
        updateCanProceed()
    }

    func resetPositions() {
        for index in antennaPositions.indices {
            let resetPosition = CGPoint(x: 50, y: 50)
            antennaPositions[index].position = resetPosition
            antennaPositions[index].normalizedPosition = CGPoint(x: 0.125, y: 0.125) // 50/400 = 0.125
        }
        updateCanProceed()
    }

    func addNewDevice(name: String) {
        print("üîÑ addNewDevice: Starting to add device '\(name)'")

        let newDevice = AndroidDevice(
            id: UUID().uuidString,
            name: name,
            isConnected: false,
            isNearbyDevice: false
        )
        print("üîÑ addNewDevice: AndroidDevice created successfully")

        selectedDevices.append(newDevice)
        print("üîÑ addNewDevice: Device added to selectedDevices, count: \(selectedDevices.count)")

        let newAntennaPosition = AntennaPosition(
            id: newDevice.id,
            deviceName: newDevice.name,
            position: CGPoint(x: 50, y: 50),
            rotation: 0.0,
            color: colors[antennaPositions.count % colors.count],
            baseCanvasSize: CGSize(width: 400, height: 400)
        )
        print("üîÑ addNewDevice: AntennaPosition created with normalized position: \(newAntennaPosition.normalizedPosition)")

        antennaPositions.append(newAntennaPosition)
        print("üîÑ addNewDevice: AntennaPosition added to array, count: \(antennaPositions.count)")

        saveSelectedDevices()
        print("üîÑ addNewDevice: Selected devices saved to UserDefaults")

        updateCanProceed()
        print("üîÑ addNewDevice: updateCanProceed called, canProceedValue: \(canProceedValue)")

        print("‚úÖ Êñ∞„Åó„ÅÑ„Éá„Éê„Ç§„Çπ„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü: \(name)")
    }

    func removeDevice(_ deviceId: String) {
        selectedDevices.removeAll { $0.id == deviceId }
        antennaPositions.removeAll { $0.id == deviceId }

        saveSelectedDevices()
        updateCanProceed()

        print("üóëÔ∏è „Éá„Éê„Ç§„Çπ„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü: \(deviceId)")
    }

    // MARK: - SwiftDataÈñ¢ÈÄ£„É°„ÇΩ„ÉÉ„Éâ

    private func loadAntennaPositionsFromSwiftData() {
        guard let repository = swiftDataRepository,
              let floorMapInfo = floorMapInfo else { return }

        Task {
            do {
                let positions = try await repository.loadAntennaPositions(for: floorMapInfo.id)
                await MainActor.run {
                    // SwiftData„Åã„ÇâË™≠„ÅøËæº„Çì„Å†‰ΩçÁΩÆÊÉÖÂ†±„ÇíÁèæÂú®„ÅÆantennaPositions„Å´ÈÅ©Áî®
                    for position in positions {
                        if let index = antennaPositions.firstIndex(where: { $0.id == position.antennaId }) {
                            // „Çπ„Ç±„Éº„É´Â§âÊèõ: ÂÆü‰∏ñÁïåÂ∫ßÊ®ô„Åã„Çâ„Éî„ÇØ„Çª„É´Â∫ßÊ®ô„Å∏
                            let pixelX = CGFloat(position.position.x / mapScale)
                            let pixelY = CGFloat(position.position.y / mapScale)

                            // Âü∫Ê∫ñ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Åß„ÅÆ‰ΩçÁΩÆ„ÇíË®≠ÂÆö
                            antennaPositions[index].position = CGPoint(x: pixelX, y: pixelY)
                            // Ê≠£Ë¶èÂåñÂ∫ßÊ®ô„ÇÇÊõ¥Êñ∞
                            antennaPositions[index].normalizedPosition = CGPoint(
                                x: pixelX / 400.0,
                                y: pixelY / 400.0
                            )
                            antennaPositions[index].rotation = position.rotation
                        }
                    }
                    updateCanProceed()
                    print("üì± SwiftData„Åã„Çâ„Ç¢„É≥„ÉÜ„Éä‰ΩçÁΩÆ„ÇíË™≠„ÅøËæº„ÅøÂÆå‰∫Ü: \(positions.count)‰ª∂ for floorMap: \(floorMapInfo.id)")
                }
            } catch {
                print("‚ùå SwiftData„Åã„Çâ„ÅÆË™≠„ÅøËæº„Åø„Ç®„É©„Éº: \(error)")
            }
        }
    }

    private func saveAntennaPositionToSwiftData(_ antennaPosition: AntennaPosition) {
        guard let repository = swiftDataRepository,
              let floorMapInfo = floorMapInfo else { return }

        Task {
            do {
                // „Éî„ÇØ„Çª„É´Â∫ßÊ®ô„ÇíÂÆü‰∏ñÁïåÂ∫ßÊ®ô„Å´Â§âÊèõ
                let realWorldX = Double(antennaPosition.position.x) * mapScale
                let realWorldY = Double(antennaPosition.position.y) * mapScale

                let positionData = AntennaPositionData(
                    id: antennaPosition.id,
                    antennaId: antennaPosition.id,
                    antennaName: antennaPosition.deviceName,
                    position: Point3D(x: realWorldX, y: realWorldY, z: 0.0),
                    rotation: antennaPosition.rotation,
                    floorMapId: floorMapInfo.id
                )

                // Êó¢Â≠ò„ÅÆ„É¨„Ç≥„Éº„Éâ„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ„Åó„Å¶Êõ¥Êñ∞ or Êñ∞Ë¶è‰ΩúÊàê
                try await repository.saveAntennaPosition(positionData)
                print("üíæ SwiftData„Å´„Ç¢„É≥„ÉÜ„Éä‰ΩçÁΩÆ„Çí‰øùÂ≠ò: \(antennaPosition.deviceName) for floorMap: \(floorMapInfo.id)")
            } catch {
                print("‚ùå SwiftData„Å∏„ÅÆ‰øùÂ≠ò„Ç®„É©„Éº: \(error)")
            }
        }
    }

    private func saveSelectedDevices() {
        if let encoded = try? JSONEncoder().encode(selectedDevices) {
            UserDefaults.standard.set(encoded, forKey: "SelectedUWBDevices")
            print("üíæ ÈÅ∏Êäû„Éá„Éê„Ç§„Çπ‰∏ÄË¶ß„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü: \(selectedDevices.count)Âè∞")
        }
    }

    func saveAntennaPositions() {
        guard let floorMapInfo = floorMapInfo else { return }
        
        let positionData = antennaPositions.map { antenna in
            AntennaPositionData(
                antennaId: antenna.id,
                antennaName: antenna.deviceName,
                position: Point3D(x: antenna.position.x, y: antenna.position.y, z: 0.0),
                rotation: antenna.rotation,
                floorMapId: floorMapInfo.id
            )
        }

        if let encoded = try? JSONEncoder().encode(positionData) {
            UserDefaults.standard.set(encoded, forKey: "configuredAntennaPositions")
            print("üíæ „Ç¢„É≥„ÉÜ„Éä‰ΩçÁΩÆ„Éá„Éº„Çø„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü: \(positionData.count)Âè∞")
        }
    }

    func saveAntennaPositionsForFlow() -> Bool {
        print("üîÑ saveAntennaPositionsForFlow: Starting save process")
        print("üîÑ saveAntennaPositionsForFlow: Total antennas = \(antennaPositions.count)")

        // ÈÖçÁΩÆ„Åï„Çå„Åü„Ç¢„É≥„ÉÜ„Éä„ÅÆÊï∞„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        let positionedAntennas = antennaPositions.filter { $0.position != CGPoint(x: 50, y: 50) }
        print("üîÑ saveAntennaPositionsForFlow: Positioned antennas = \(positionedAntennas.count)")

        for (index, antenna) in antennaPositions.enumerated() {
            print("üîÑ Antenna \(index): \(antenna.deviceName) at (\(antenna.position.x), \(antenna.position.y))")
        }

        guard positionedAntennas.count >= 2 else {
            print("‚ùå saveAntennaPositionsForFlow: Need at least 2 positioned antennas, got \(positionedAntennas.count)")
            return false
        }

        // ÂõûËª¢ËßíÂ∫¶„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÂøÖÈ†à„Åß„ÅØ„Å™„ÅÑ„Åå„ÄÅÊé®Â•®Ôºâ
        let _ = positionedAntennas.filter { $0.rotation != 0.0 }

        // „Éá„Éº„Çø„Çí‰øùÂ≠ò
        print("üíæ saveAntennaPositionsForFlow: Saving antenna positions")
        saveAntennaPositions()
        
        // „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÄ≤Ë°åÁä∂Ê≥Å„ÇíÊõ¥Êñ∞
        updateProjectProgress(toStep: .antennaConfiguration)

        print("‚úÖ saveAntennaPositionsForFlow: Save completed successfully")
        return true
    }

    private func convertToRealWorldPosition(_ screenPosition: CGPoint) -> RealWorldPosition {
        // „Éû„ÉÉ„Éó„ÅÆÂÆüÈöõ„ÅÆ„Çµ„Ç§„Ç∫„Å®„Çπ„ÇØ„É™„Éº„É≥‰∏ä„ÅÆ„Çµ„Ç§„Ç∫„ÅÆÊØîÁéá„ÇíË®àÁÆó
        // UserDefaults„Åã„Çâ„Éï„É≠„Ç¢„Éû„ÉÉ„ÉóÊÉÖÂ†±„ÇíÂèñÂæó
        guard let mapData = UserDefaults.standard.data(forKey: "currentFloorMapInfo"),
              let floorMapData = try? JSONDecoder().decode(FloorMapInfo.self, from: mapData) else {
            return RealWorldPosition(x: Double(screenPosition.x), y: Double(screenPosition.y), z: 0)
        }

        let canvasSize = CGSize(width: 400, height: 400)
        let scaleX = floorMapData.width / Double(canvasSize.width)
        let scaleY = floorMapData.depth / Double(canvasSize.height)

        let realX = Double(screenPosition.x) * scaleX
        let realY = Double(screenPosition.y) * scaleY

        return RealWorldPosition(x: realX, y: realY, z: 0)
    }
    
    // MARK: - „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÄ≤Ë°åÁä∂Ê≥ÅÊõ¥Êñ∞
    
    private func updateProjectProgress(toStep step: SetupStep) {
        guard let repository = swiftDataRepository,
              let floorMapInfo = floorMapInfo else { return }
        
        Task {
            do {
                // Êó¢Â≠ò„ÅÆÈÄ≤Ë°åÁä∂Ê≥Å„ÇíÂèñÂæó
                var projectProgress = try await repository.loadProjectProgress(for: floorMapInfo.id)
                
                if projectProgress == nil {
                    // ÈÄ≤Ë°åÁä∂Ê≥Å„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊñ∞Ë¶è‰ΩúÊàê
                    projectProgress = ProjectProgress(
                        floorMapId: floorMapInfo.id,
                        currentStep: step
                    )
                } else {
                    // Êó¢Â≠ò„ÅÆÈÄ≤Ë°åÁä∂Ê≥Å„ÇíÊõ¥Êñ∞
                    projectProgress!.currentStep = step
                    projectProgress!.completedSteps.insert(step)
                    projectProgress!.updatedAt = Date()
                }
                
                try await repository.updateProjectProgress(projectProgress!)
                print("‚úÖ „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÄ≤Ë°åÁä∂Ê≥Å„ÇíÊõ¥Êñ∞: \(step.displayName)")
                
            } catch {
                print("‚ùå „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÈÄ≤Ë°åÁä∂Ê≥Å„ÅÆÊõ¥Êñ∞„Ç®„É©„Éº: \(error)")
            }
        }
    }
}

// MARK: - Data Models

struct AntennaPosition: Identifiable {
    let id: String
    let deviceName: String
    var position: CGPoint           // Ë°®Á§∫Áî®„ÅÆÂÆüÈöõ„ÅÆÂ∫ßÊ®ôÔºà„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫‰æùÂ≠òÔºâ
    var normalizedPosition: CGPoint // Ê≠£Ë¶èÂåñ„Åï„Çå„ÅüÂ∫ßÊ®ôÔºà0-1„ÅÆÁØÑÂõ≤„ÄÅ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫Èùû‰æùÂ≠òÔºâ
    var rotation: Double = 0.0
    let color: Color

    // ÂàùÊúüÂåñÊôÇ„Å´Ê≠£Ë¶èÂåñÂ∫ßÊ®ô„ÇíÂü∫Ê∫ñ„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„Åã„ÇâË®àÁÆó
    init(id: String, deviceName: String, position: CGPoint, rotation: Double = 0.0, color: Color, baseCanvasSize: CGSize = CGSize(width: 400, height: 400)) {
        self.id = id
        self.deviceName = deviceName
        self.position = position
        normalizedPosition = CGPoint(
            x: position.x / baseCanvasSize.width,
            y: position.y / baseCanvasSize.height
        )
        self.rotation = rotation
        self.color = color
    }

    // Ê≠£Ë¶èÂåñÂ∫ßÊ®ô„Åã„ÇâÂàùÊúüÂåñ
    init(id: String, deviceName: String, normalizedPosition: CGPoint, rotation: Double = 0.0, color: Color, canvasSize: CGSize) {
        self.id = id
        self.deviceName = deviceName
        self.normalizedPosition = normalizedPosition
        position = CGPoint(
            x: normalizedPosition.x * canvasSize.width,
            y: normalizedPosition.y * canvasSize.height
        )
        self.rotation = rotation
        self.color = color
    }

    // View„ÅßAntennaPosition‰ΩúÊàêÁî®„ÅÆÂàùÊúüÂåñÔºà‰ΩçÁΩÆ„Å®Ê≠£Ë¶èÂåñ‰ΩçÁΩÆ„ÇíÁõ¥Êé•ÊåáÂÆöÔºâ
    init(id: String, deviceName: String, position: CGPoint, normalizedPosition: CGPoint, rotation: Double = 0.0, color: Color) {
        self.id = id
        self.deviceName = deviceName
        self.position = position
        self.normalizedPosition = normalizedPosition
        self.rotation = rotation
        self.color = color
    }
}

// DomainÂ±§„ÅÆAntennaPositionData„Å®RealWorldPosition„Çí‰ΩøÁî®
